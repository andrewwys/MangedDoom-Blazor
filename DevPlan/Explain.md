# MangedDoom-Blazor Codebase Analysis

## 1. Project Overview

This project is a port of the original [Managed Doom](https://github.com/sinshu/managed-doom), a C# port of the classic Doom game, to the web using Blazor WebAssembly. The primary goal is to run the Doom game engine entirely in the browser, providing a playable demo.

**Key Features:**
- Renders the classic Doom game in a web browser.
- Basic keyboard controls for gameplay.

**Technology Stack:**
- **Frontend:** Blazor WebAssembly
- **Backend/Game Logic:** .NET / C#
- **Build Tools:** `dotnet` CLI

## 2. Architecture

The application follows a simple architecture where a Blazor WebAssembly app hosts the `ManagedDoom` game engine. The solution consists of a single project, `BlazorDoom`, which contains both the Blazor-specific code and the `ManagedDoom` source code in a subdirectory.

**Architectural Pattern:**
The project uses a **JavaScript Interop** pattern to communicate between the C# code running on WebAssembly and the JavaScript running in the browser. 

**Data Flow:**
1.  **Initialization:** The application starts with the `Main` method in `BlazorDoom.cs`. It calls `LoadWad`, which asynchronously fetches the Doom WAD file and a SoundFont file from the server. It then creates an instance of `ManagedDoom.DoomApplication`.
2.  **Game Loop:** A JavaScript-driven game loop (likely using `requestAnimationFrame`) calls the C# `GameLoop` method, passing user input (key presses).
3.  **Game Logic:** The `ManagedDoom` engine processes the input, updates the game state, and generates a new frame buffer and audio data.
4.  **Rendering:** The `ManagedDoom` engine calls C# methods in `Renderer.cs`, which in turn call JavaScript functions (`renderOnJS`, `playSoundOnJS`, `playMusicOnJS`) to render the frame to an HTML `<canvas>` element and play audio through the browser's audio APIs.

## 3. Key Components

### `MainJS` Class (`BlazorDoom.cs`)
This static partial class acts as the primary bridge between the JavaScript environment and the C#/.NET game logic. It's responsible for the lifecycle of the game.

- **`[JSExport]` Methods:** It exports `LoadWad` and `GameLoop` to be called from JavaScript.
  - `LoadWad`: Initializes the game by fetching the necessary assets (`.wad` file, sound font) via HTTP requests and instantiating the `ManagedDoom.DoomApplication`.
  - `GameLoop`: Represents a single tick of the game. It's called repeatedly from the browser's rendering loop (e.g., `requestAnimationFrame`) and passes keyboard input state to the game engine.
- **`[JSImport]` Methods:** It imports `getBaseUrl` from a JavaScript file (`main.js`) to correctly resolve asset paths.

### `Renderer.cs`
This class handles the output of the game engine, specifically rendering and audio. It uses JavaScript interop to send the data generated by the C# game engine to the browser for presentation.

- **`renderOnJS`:** This method is called by the game engine with the screen buffer (as a `byte[]`) and the color palette. It passes this data to a JavaScript function that renders it to an HTML `<canvas>`.
- **`playSoundOnJS` & `playMusicOnJS`:** These methods are called by the game engine's audio system. They pass raw audio sample data to JavaScript functions that use browser APIs (like the Web Audio API) to play the sounds and music.

### `ManagedDoom` Integration
The project includes the source code for `ManagedDoom` directly within the `ManagedDoom/` subdirectory. This is not a package dependency but a direct source inclusion. The original `ManagedDoom` code has likely been modified to support the Blazor hosting environment:

- **Rendering and Audio:** The original rendering and audio systems, which would have targeted desktop APIs, have been replaced with calls to the methods in `Renderer.cs`. This effectively retargets the game's output to the browser.
- **File System:** The file loading logic has been adapted to fetch game assets over HTTP using `HttpClient`, as seen in the `LoadWad` method.

## 4. Build and Deployment

The build and deployment process is managed through the standard `dotnet` CLI.

### Prerequisites
Before building the project, the following .NET workloads and tools must be installed:
```sh
dotnet workload install wasm-tools wasm-experimental
dotnet tool install -g dotnet-serve
```

### Local Build & Run
The project can be built and served locally using the following commands:

1.  **Publish the application:** This command compiles the C# code, links the .NET runtime for WebAssembly, and places all the necessary files in the `bin/Release/net9.0/publish/wwwroot` directory.
    ```sh
    dotnet publish -c Release BlazorDoom.csproj
    ```

2.  **Serve the application:** This command starts a local web server to serve the published files. The `-S` flag enables HTTPS, and the `--path-base` argument is crucial for ensuring the application's assets are loaded correctly under the specified URL path.
    ```sh
    dotnet serve -d:bin/Release/net9.0/publish/wwwroot -p 8080 -S --path-base '/MangedDoom-Blazor'
    ```

After running these commands, the application can be accessed at `http://localhost:8080/MangedDoom-Blazor/`.

### Deployment
For production deployment, the contents of the `bin/Release/net9.0/publish/wwwroot` directory should be hosted on a static web server. The server must be configured to handle the specified path base (`/MangedDoom-Blazor`) correctly, which might require URL rewriting rules on the server.

## 5. Dependencies

The project has a minimal set of external dependencies, relying mostly on the .NET SDK and in-project source code.

### .NET Dependencies
- **.NET 9.0 SDK:** The project is built using .NET 9.0.
- **`Microsoft.NET.Sdk.WebAssembly`:** This SDK is the foundation for the Blazor WebAssembly application.
- **`wasm-tools` and `wasm-experimental`:** These .NET workloads are required for WebAssembly compilation and tooling.

### Source Code Dependencies
- **`ManagedDoom`:** The source code for the Doom engine is included directly in the `ManagedDoom/` directory. It is not referenced as a separate library or NuGet package.

### JavaScript Dependencies
- **`html5-virtual-game-controller`:** As mentioned in the `README.md`, this library is used for the on-screen virtual controller, likely for mobile or touch-based input.
- **Custom JavaScript Interop Files:** The application relies on custom JavaScript files for rendering and audio playback, as referenced in `Renderer.cs` (`blazorDoom/renderer.js`) and `BlazorDoom.cs` (`main.js`).

## 6. Future Improvements

Based on the `README.md` and a general analysis of the project, here are several areas for future improvement.

### From the `README.md` TODO List
- **Implement Mouse Controls:** This would involve capturing mouse events in JavaScript and passing the relevant data (e.g., movement deltas) to the C# `GameLoop`.
- **Implement Save and Load:** This is a more complex feature. A possible approach would be to serialize the game state in C# and use JavaScript interop to store it in the browser's `localStorage` or `IndexedDB`. The game could then be reloaded from this saved state.

### Technical Debt & Potential Refinements
- **Consolidate JavaScript Interop:** The JavaScript interop calls are spread across `Renderer.cs` and `BlazorDoom.cs`. These could be centralized into a single, more organized module for better maintainability.
- **Formalize `ManagedDoom` Modifications:** The modifications made to the `ManagedDoom` source code are not explicitly documented. It would be beneficial to either fork the original repository and commit the changes there or clearly document every change made to the included source files. This would make it easier to merge updates from the original `ManagedDoom` project in the future.

### Performance Optimizations
- **WebAssembly AOT (Ahead-of-Time) Compilation:** While the project uses `wasm-tools`, explicitly enabling and optimizing with WebAssembly AOT could provide significant performance improvements by compiling the .NET code to native WebAssembly at build time.
- **Reduce JavaScript Interop Overhead:** Every call between C# and JavaScript has some overhead. For performance-critical code like rendering, it might be beneficial to explore techniques that minimize these calls, such as using shared memory (if the Blazor version and browser support it effectively) to pass data instead of copying it with each frame.
